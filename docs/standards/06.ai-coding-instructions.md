title: AI Coding Instructions (Master Guide)
description: Master coding rules for React + Vite + TypeScript Monorepo
refs:
  - ./01-biome-guidelines.md
  - ./02-typescript-standards.md
  - ./03-vite-build-guide.md
  - ./04-react-fsd-architecture.md
  - ./05-git-commit-convention.md
  - ./07-firestore-data-modeling-ai.md
  - ./08-firebase-functions-esm-v2-guide.md
  - ./09-seed-scripts-and-emulator-guide.md
---

# ü§ñ 06 ‚Äî AI Coding Instructions (Master Guide)

**Purpose:** This document defines all coding principles, rules, and constraints that AI must follow when writing or modifying code in this monorepo project.

---

## üá¨üáß Section 1: AI Master Coding Rules

### 1. Core Principle
AI must strictly follow project conventions from:

- @/standards/01-biome-guidelines.md  
- @/standards/02-typescript-standards.md  
- @/standards/03-vite-build-guide.md  
- @/standards/04-react-fsd-architecture.md  
- @/standards/05-git-commit-convention.md  
- @/standards/07-firestore-data-modeling-ai.md  
- @/standards/08-firebase-functions-esm-v2-guide.md  

No deviation or personal style is allowed unless explicitly requested.

---

### 2. Code Quality Requirements
- Code must compile with zero TypeScript errors.
- Code must pass **Biome** lint/format check (`pnpm biome check .`).
- Code must use **TypeScript strict mode**.
- Code must follow **Feature-Slice Design**.
- Code must never break import aliasing (`@/`).
- Code must **not** use `any` or `@ts-ignore`.
- Code must include clear type definitions for all functions and props.

---

### 3. Folder & File Rules
- Use `.tsx` for any file containing JSX.
- Use `.ts` for pure logic, hooks, or service layers.
- Files must follow this placement:

| Category    | Path                                                                 |
|-------------|----------------------------------------------------------------------|
| Components  | `src/domains/<domain>/features/<feature>/components/`                |
| Hooks       | `src/domains/<domain>/features/<feature>/hooks/`                     |
| Services    | `src/domains/<domain>/features/<feature>/services/`                  |
| Schemas     | `src/domains/<domain>/features/<feature>/schemas/`                   |
| Types       | `src/domains/<domain>/features/<feature>/types/`                     |
| Shared      | `src/shared/...`                                                     |

---

### 4. Import Rules
- Always use alias imports (`@/shared/...`) ‚Äî never use deep relative paths like `../../../`.
- Import order must follow Biome rules:
  1) Node/React  
  2) Third-party libs  
  3) Internal shared packages (e.g., `@ecolife/ui-core`, `@ecolife/design-tokens`)  
  4) Local feature/domain imports
- Type-only imports use `import type`.

**Example:**
```ts
import { Button } from 'antd';
import type { FC } from 'react';
import type { Employee } from '@/shared/types';
import { formatMoney } from '@/shared/lib/format';
5. TypeScript Behavior
Use explicit types for parameters and returns.

Prefer type aliases; use interface only when extending.

Use enum sparingly (numeric/string key mapping only).

Use generics where inference is insufficient.

Never use:

ts
‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
// Forbidden
const x: any = ...
// Forbidden
// @ts-ignore
6. React / Hook Behavior
Component names: PascalCase

Hook names: useCamelCase

Hooks cannot contain JSX unless the file is .tsx.

Example hook:

ts
‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
export const useEmployeeList = () => {
  const queryClient = useQueryClient();
  return useQuery(employeeKeys.list(), employeeService.getAll);
};
7. Service Layer
All API or external data logic must live under services/.

Each service should return typed promises.

Example:

ts
‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
export const employeeService = {
  async getAll(): Promise<Employee[]> { /* ... */ },
  async create(data: CreateEmployeeInput): Promise<void> { /* ... */ },
};
8. Schema and Validation
Use zod for validation schema.

Export both the schema and inferred type:

ts
‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
export const EmployeeFormSchema = z.object({
  firstName: z.string().min(1),
  lastName: z.string().min(1),
});
export type EmployeeFormInput = z.infer<typeof EmployeeFormSchema>;
9. Git & Commit Behavior
Always follow the Conventional Commit format:

php-template
‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
<type>(<scope>): <message>
Use small commits with one logical change.

Run lint and typecheck before committing.

Example:

scss
‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
feat(employee): add employee create form
fix(auth): refresh token expiration logic
10. Build and Run Behavior
Build using:

bash
‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
pnpm build
Preview production build using:

bash
‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
pnpm preview
Environment variables must start with VITE_.

Output directory must be dist/.

11. Error Handling
Use try/catch for async operations.

Use clear, contextual error messages.

Example:

ts
‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
try {
  await employeeService.create(data);
} catch (err) {
  console.error('Failed to create employee', err);
}
12. Performance & Scalability
Use React Query for async data fetching and caching.

Use memoization (useMemo, useCallback) where appropriate.

Avoid unnecessary re-renders and global states.

Split large components into smaller, reusable parts.

13. AI Output Formatting
All AI code output must:

Include necessary imports.

Be ready to compile without modification.

Follow TypeScript + Biome + FSD + Git standards.

Include only relevant code (no explanations inside code blocks).

14. Firestore Data Modeling ‚Äî must follow @/standards/07
Design collections based on query patterns (not just relationships).

Use subcollections for strong ownership (e.g., employees/{id}/attendance).

Use arrays only for small, static membership lists.

Use maps for grouped values updated together.

Apply intentional denormalization (copy fields like employeeName) to speed up reads.

Enforce consistency using Cloud Functions triggers or transactions.

Choose client vs Cloud Functions according to access level and data security:

Client: simple, user-owned writes.

Cloud Functions: privileged, multi-document, or server-side aggregation.

Each document should include:

tenantId, ownerId (if applicable)

createdAt, updatedAt (using serverTimestamp())

Use Timestamp (UTC) for all times.

15. Firebase Functions (ESM v2) ‚Äî must follow @/standards/08
Use ESM ("type": "module") and TS "module": "NodeNext".

Use Functions v2 only:

ts
‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î
import { onCall, HttpsError, type CallableRequest } from 'firebase-functions/v2/https';
import * as logger from 'firebase-functions/logger';
import { getFirestore, FieldValue, Timestamp, type Query, type DocumentData } from 'firebase-admin/firestore';
import { getAuth } from 'firebase-admin/auth';
Never use any in catch ‚Äî use unknown and type narrow safely.

Avoid as any in Firestore; prefer Query<DocumentData>.

Respect Biome formatting for multi-line throws.

Maintain proper import order and use import type where applicable.

Keep runtime logic consistent with @/standards/08.

## 16. RBAC (Role-Based Access Control) ‚Äî must follow

**Core Principles:**

- Always use the RBAC system for permission checking
- Never hardcode role/permission checks
- Use hooks and components provided by the RBAC feature

**Permission Types:**

- **Base permissions**: `read`, `create`, `update`, `delete`
- **Context-based permissions**: `read:own`, `read:all`, `update:own`, `update:all`

**Scope Semantics:**

- `:all` ‚Äî can access all data
- `:own` ‚Äî can only access own data
- If no scope specified (e.g., `read`), default is `:all`

**Permission Checking Patterns:**

```ts
// ‚úÖ Good: Use hooks
import { usePermission } from '@/domains/system/features/rbac';

function MyComponent() {
  const { hasPermission } = usePermission();

  if (hasPermission('employees', 'read:all')) {
    // Can read all employee data
  }

  if (hasPermission('employees', 'read:own')) {
    // Can only read own employee data
  }
}

// ‚úÖ Good: Use PermissionGuard
<PermissionGuard resource="employees" permission="create">
  <CreateButton />
</PermissionGuard>

// ‚úÖ Good: Use withPermission HOC
export default withPermission(EmployeeCreatePage, {
  resource: 'employees',
  permission: 'create',
  redirectTo: '/unauthorized',
});

// ‚ùå Bad: Hardcoded role checks
if (user.role === 'admin') { // Don't do this!
  // ...
}
```

**Permission Matrix Structure:**

- All permissions are stored in `rolePermissions` collection
- Use `permissionService` for backend operations
- Use `checkPermission` utility for frontend checks

**Context-Based Permission Rules:**

- **Employee role** ‚Üí Use `:own` scope (e.g., `read:own`, `update:own`)
- **Manager/HR/Admin** ‚Üí Use `:all` scope (e.g., `read:all`, `update:all`)

**When querying data:**

- If user has `:all` scope, query all documents
- If user has `:own` scope, filter by `userId`/`ownerId`

**Example Implementation:**

```ts
import { useAuth } from '@/domains/system/features/auth/hooks/useAuth';
import { getPermissionScope } from '@/domains/system/features/rbac';

function useEmployees() {
  const { user } = useAuth();
  const scope = getPermissionScope(user.role, 'employees', 'read');

  return useQuery({
    queryKey: ['employees', scope],
    queryFn: () => {
      if (scope === 'all') {
        return employeeService.getAll();
      }
      if (scope === 'own') {
        return employeeService.getByUserId(user.uid);
      }
      throw new Error('No permission');
    },
  });
}
```

**Admin Panel for Permission Management:**

- Navigate to `/permissions` to manage role permissions
- Use `EditPermissionModal` to modify permissions
- Use `PermissionMatrixTable` to view all permissions

**Security Rules:**

- ‚ö†Ô∏è **ALWAYS validate permissions on backend** (Cloud Functions or Firestore Rules)
- ‚úÖ Client-side checks are for UX only
- ‚úÖ Never expose sensitive data based on client-side checks alone