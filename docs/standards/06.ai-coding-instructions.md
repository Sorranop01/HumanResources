title: AI Coding Instructions (Human Master Guide)
description: Master coding rules for React + Vite + TypeScript Monorepo ‚Äî Human Resources System
refs:

- ./01-biome-guidelines.md
- ./02-typescript-standards.md
- ./03-vite-build-guide.md
- ./04-react-fsd-architecture.md
- ./05-git-commit-convention.md
- ./07-firestore-data-modeling-ai.md
- ./08-firebase-functions-esm-v2-guide.md
- ./09-seed-scripts-and-emulator-guide.md
- ./10-Single-Source-of-Truth-Zod.md

---

# üß† 06 ‚Äî AI Coding Instructions (Human Master Guide)

**Purpose:**  
This document defines all coding principles, rules, and constraints that AI must follow when writing or modifying code in the **Human Resources Monorepo** ‚Äî a React + Firebase-based HR System for managing employees, teams, candidates, and performance.

---

## üá¨üáß Section 1: AI Master Coding Rules

### 1. Core Principle

AI must strictly follow project conventions from:

- @/standards/01-biome-guidelines.md
- @/standards/02-typescript-standards.md
- @/standards/03-vite-build-guide.md
- @/standards/04-react-fsd-architecture.md
- @/standards/05-git-commit-convention.md
- @/standards/07-firestore-data-modeling-ai.md
- @/standards/08-firebase-functions-esm-v2-guide.md

‚ö†Ô∏è No deviation or personal style is allowed unless explicitly requested.

---

### 2. Code Quality Requirements

- Code must compile with **zero TypeScript errors**.
- Must pass **Biome lint/format check** (`pnpm biome check .`).
- Must use **TypeScript strict mode**.
- Must follow **Feature-Sliced Design (FSD)**.
- Must respect **import aliases** (`@/...`).
- Must **not** use `any` or `@ts-ignore`.
- Must define clear types for all props, functions, and return values.

---

### 3. Folder & File Structure

| Category         | Path Example                                          |
| ---------------- | ----------------------------------------------------- |
| Components       | `src/domains/<domain>/features/<feature>/components/` |
| Hooks            | `src/domains/<domain>/features/<feature>/hooks/`      |
| Services         | `src/domains/<domain>/features/<feature>/services/`   |
| Schemas          | `src/domains/<domain>/features/<feature>/schemas/`    |
| Types (UI Props) | `src/domains/<domain>/features/<feature>/types/`      |
| Shared           | `src/shared/...`                                      |

üß© Domains represent business areas like:  
`people/`, `positions/`, `teams/`, `candidates/`, `performance/`, `system/`.

## ‚ö†Ô∏è SSOT Rule on Types: Data Model Types (e.g., Employee, Candidate) must not be placed in the types/ folder. They must be inferred (z.infer) from their corresponding Zod schema in the schemas/ folder, following the Single Source of Truth strategy in @/standards/10-Single-Source-of-Truth-Zod.md. The types/ folder is reserved strictly for UI-related prop types (e.g., EmployeeFormProps).

### 4. Import Rules

- Always use **alias imports** (`@/shared/...`), never deep relative paths (`../../../`).
- Import order must follow Biome rules:

  1. Node/React
  2. Third-party libs
  3. Internal packages (`@human/ui-core`, `@human/types`)
  4. Local domain/feature imports

- Type-only imports use `import type`.

**Example:**

```ts
import { Button } from "@human/ui-core";
import type { FC } from "react";
import { formatDate } from "@/shared/utils/date";
import type { Employee } from "@/domains/people/types";
```

---

### 5. TypeScript Behavior

- Use **explicit types** for all parameters and returns.
- Prefer **type aliases** over interfaces unless extending.
- Avoid using enums for strings ‚Äî use union types instead.
- Use generics when inference is insufficient.

‚ùå Forbidden:

```ts
const data: any = ...
// or
// @ts-ignore
```

---

### 6. React / Hook Behavior

- Component names ‚Üí **PascalCase**
- Hook names ‚Üí **useCamelCase**
- Hooks cannot contain JSX unless file is `.tsx`

**Example:**

```ts
export const useEmployeeList = () => {
  const queryClient = useQueryClient();
  return useQuery(employeeKeys.list(), employeeService.getAll);
};
```

---

### 7. Service Layer (API / Firestore)

All backend logic (Firestore, REST APIs, etc.) lives under `services/`.  
Each service must return **typed promises**.

**Example:**

```ts
export const employeeService = {
  async getAll(): Promise<Employee[]> {
    const snap = await getDocs(collection(db, "employees"));
    return snap.docs.map((d) => ({
      id: d.id,
      ...(d.data() as Omit<Employee, "id">),
    }));
  },
  async create(data: CreateEmployeeInput): Promise<void> {
    await addDoc(collection(db, "employees"), data);
  },
};
```

---

### 8. Schema & Validation

Use **Zod** for validation.  
Export both schema and inferred types.

```ts
export const EmployeeFormSchema = z.object({
  firstName: z.string().min(1),
  lastName: z.string().min(1),
  positionId: z.string(),
});

export type EmployeeFormInput = z.infer<typeof EmployeeFormSchema>;
```

---

### 9. Git & Commit Rules

Follow **Conventional Commit**:

```
<type>(<scope>): <message>
```

‚úÖ Example:

```
feat(people): add employee creation form
fix(auth): correct token refresh logic
```

Run lint & type-check before commit:

```bash
pnpm lint && pnpm typecheck
```

---

### 10. Build & Run

**Build:**

```bash
pnpm build
```

**Preview:**

```bash
pnpm preview
```

- Environment variables must start with `VITE_`.
- Output directory ‚Üí `dist/`.

---

### 11. Error Handling

Always use `try/catch` with contextual messages.

```ts
try {
  await employeeService.create(data);
} catch (err: unknown) {
  console.error("‚ùå Failed to create employee", err);
}
```

---

### 12. Performance & Scalability

- Use **React Query** for async data and caching.
- Use `useMemo` / `useCallback` for memoization.
- Avoid unnecessary global state.
- Split large components into smaller ones.

---

### 13. AI Output Formatting

AI-generated code must:

‚úÖ Include imports  
‚úÖ Compile without modification  
‚úÖ Follow TypeScript + Biome + FSD standards  
‚úÖ Contain only code (no inline explanations)

---

### 14. Firestore Data Modeling ‚Äî must follow `@/standards/07`

| Collection   | Description                        |
| ------------ | ---------------------------------- |
| `employees`  | Core employee profiles             |
| `teams`      | Department / group structure       |
| `positions`  | Job titles / descriptions          |
| `candidates` | Applicants and recruitment process |
| `reviews`    | Performance and OKR evaluations    |
| `users`      | System users and roles             |

**Rules:**

- Design collections around **query patterns**, not relations.
- Use subcollections for strong ownership (`employees/{id}/attendance`).
- Use maps for grouped values; use arrays only for small sets.
- Denormalize frequently accessed fields (e.g., `employeeName`).
- Include: `tenantId`, `createdAt`, `updatedAt` (via `serverTimestamp()`).
- Use UTC timestamps.
- Multi-document writes ‚Üí use Cloud Functions (transactions).

---

### 15. Firebase Functions (ESM v2) ‚Äî must follow `@/standards/08`

Use ESM modules and Functions v2 API.

```ts
import { onCall, HttpsError } from "firebase-functions/v2/https";
import { getFirestore, Timestamp } from "firebase-admin/firestore";

export const createEmployee = onCall(async (req) => {
  const db = getFirestore();
  await db.collection("employees").add({
    ...req.data,
    createdAt: Timestamp.now(),
  });
});
```

**Rules:**

- Use `"type": "module"` & TS `"module": "NodeNext"`.
- Never use `any` in `catch` blocks.
- Prefer `unknown` + safe narrowing.
- Keep consistent with `@/standards/08`.
- **Schema Isolation:** Functions must NOT import schemas from frontend `src/` directory. Schemas needed by Functions must be placed in `functions/src/schemas/` and adapted for Firebase Admin SDK (use `firebase-admin/firestore` instead of `firebase/firestore`).

---

### 16. RBAC (Role-Based Access Control)

**Principles:**

- Always check permissions using RBAC system.
- Never hardcode role checks.
- Use hooks/components from `system/features/rbac`.

**Permission Types:**

- Base: `read`, `create`, `update`, `delete`
- Scoped: `read:own`, `read:all`, `update:own`, `update:all`

**Example:**

```ts
import { usePermission } from "@/domains/system/features/rbac";

function EmployeeList() {
  const { hasPermission } = usePermission();
  if (hasPermission("employees", "read:all")) {
    // full access
  }
}
```

‚úÖ Use `<PermissionGuard>`:

```tsx
<PermissionGuard resource="employees" permission="create">
  <CreateEmployeeButton />
</PermissionGuard>
```

‚ùå Avoid:

```ts
if (user.role === 'admin') { ... } // Hardcoded check
```

**Security Rules:**

- Backend must validate permissions (Firestore rules or Functions).
- Client-side checks are for UX only.

---

## ‚úÖ Summary

Human HR Monorepo follows **four golden principles:**

1. **Type Safety** ‚Äî every layer must use strict TypeScript types.
2. **Domain Isolation** ‚Äî code lives inside its domain/feature only.
3. **Functions Isolation** ‚Äî Firebase Functions must never import from frontend `src/`. All shared schemas must be duplicated in `functions/src/schemas/` with Firebase Admin SDK compatibility.
4. **Consistency** ‚Äî always align with Biome, FSD, and Firestore data rules.

---

> üß© Part of the official **Human Developer Handbook**
> Maintained by: **GPT-5 AI Developer System**
> Last updated: **2025-11-14**
